const db = {
	name: 'DB',
	path: {
		name: 'Path',
		to: {
			name: 'To',
			dir: {
				name: 'Dir',
				child: {
					name: 'Child',
					end: {
						name: 'End',
						last: {
							name: 'Last'
						}
					}
				}
			},
			array: [{
				name: 'obj1',
				child: {
					name: 'Child1 in 1'
				}
			}, {
				name: 'obj3',
				child: {
					name: 'Child1 in 2'
				}
			}, {
				name: 'obj2',
				child: {
					name: 'Child1 in not 2'
				}
			}]
		}
	}
};
(() => {
	const pathToArray = (path = '') => {
		if (typeof path !== 'string') return [];
		let paths = path.split('/');
		if (paths[0] === '') paths.splice(0, 1);
		if (paths[paths.length - 1] === '') paths.splice(paths.length - 1, 1);
		return paths;
	};
	const createObjectFromArray = (array = []) => {
		let obj = {};
		if (array.length === 0) return {};
		array.reverse();
		array.forEach(p => {
			let _obj = {};
			_obj[p] = obj;
			obj = _obj
		});
		return obj;
	};
	const readDB = (path = '', db) => {
		let obj = db,
			paths = pathToArray(path);
		// console.log('Paths: ', paths, db);
		if (path === '') return obj; // Return back the database, If path is empty.
		paths.forEach((p, i, a) => {
			if (obj != undefined && obj[p] != undefined) {
				obj = obj[p];
			} else {
				console.error(new Error(`Unable to find ${p} in the Object: `).message, db);
				obj = {};
				a.length = 0;
			}
		});
		return obj
	}
	const writeDB = (path = '', db, value = {}) => {
		let obj = db,
			paths = pathToArray(path);
		for (let i = 0; i < paths.length; i++) {
			let p = paths[i];
			if (obj[p] != undefined) {
				obj = obj[p];
			} else {
				obj[p] = {};
				i--;
			}
		}
		obj = value;
		// db = {...obj};
		return obj;
	}

	// !TASK: Add options for each query
	function queryDB(path = '', db = {}, query = {}, options = {}) {
		let array = [],
			p = {};
		// !TASK: Switch to lodash _.get
		db = readDB(path, db); // Read Database from path
		for (let key in db) {
			// key in this case is the iterated index of the obj, just as an array is
			p = db[key];
			if (query.key != undefined) { // With key, works with objective array
				if (p[query.key] != undefined) {
					if (typeof query.value == 'object') {
						if (queryDB('', p[query.key], query.value, options).length > 0) array.push(p);
					} else {
						if (options.contains) { // For string and array
							// !TASK: loop string array and convert to lowercase before equating...
							if ((typeof p[query.key] === 'string' || Array.isArray(p[query.key])) && p[query.key].indexOf(query.value) > -1) array.push(p);
						} else if (options.ranged) { // For number
							if (typeof p[query.key] == 'number' && p[query.key] >= query.value) array.push(p);
						} else if (options.exact) { // For direct values (string, boolean, number, except object and array)
							if (p[query.key] === query.value) array.push(p);
						} else if (p[query.key] === query.value || p[query.key] >= query.value /*  || p[query.key].indexOf(query.value) */ ) array.push(p); // For all
						else array = [];
					}
				}
			} else { // Without key, works with direct array
				if (p != undefined) {
					if (typeof query.value == 'object') {
						if (queryDB('', p, query.value, options).length > 0) array.push(p);
					} else {
						if (options.contains) { // For string
							if ((typeof p === 'string' || Array.isArray(p)) && p.indexOf(query.value) > -1) array.push(p);
						} else if (options.ranged) { // For number
							if (typeof p == 'number' && p >= query.value) array.push(p);
						} else if (options.exact) { // For boolean
							if (p === query.value) array.push(p);
						} else if (p === query.value || p >= query.value /*  || p.indexOf(query.value) */ ) array.push(p); // For all
						else array = [];
					}
				}
			}
		}
		return array;
	};
	// console.log('Built object: ', createObjectFromArray(pathToArray('/path/to/db/child/end')));
	// console.log('Read DB: ', readDB('/path/to/dir/', db));
	console.log('Query DB: ', queryDB('path/to/array', db, {
		key: 'name',
		value: 'obj2'
	}, {
		exact: true
	}));
	// console.log('Write DB: ', writeDB('/path/to/dir/child/end/last', db, 'Hello'), ' !PENDING');
})();

class QueryDB extends Array {
	constructor(obj = {}, query = {}, options = {}) {
		let value = [];
		p = {};
		for (let key in obj) {
			// key in this case is the iterated index of the obj, just as an array is
			p = obj[key];
			if (query.key != undefined) { // With key, works with objective array
				if (p[query.key] != undefined) {
					if (typeof query.value == 'object') {
						if (queryDB(p[query.key], query.value, options).length > 0) array.push(p);
					} else {
						if (options.contains) { // For string and array
							// !TASK: loop string array and convert to lowercase before equating...
							if (p[query.key].indexOf(query.value) > -1) value.push(p);
						} else if (options.ranged) { // For number
							if (p[query.key] >= query.value) value.push(p);
						} else if (options.exact) { // For direct values (string, boolean, number, except object and array)
							if (p[query.key] === query.value) value.push(p);
						} else if (p[query.key] === query.value || p[query.key] >= query.value || p[query.key].indexOf(query.value)) value.push(p); // For all
						else value = [];
					}
				}
			} else { // Without key, works with direct array
				if (p != undefined) {
					if (typeof query.value == 'object') {
						if (queryDB(p, query.value, options).length > 0) array.push(p);
					} else {
						if (options.contains) { // For string
							if (p.indexOf(query.value) > -1) value.push(p);
						} else if (options.ranged) { // For number
							if (p >= query.value) value.push(p);
						} else if (options.exact) { // For boolean
							if (p === query.value) value.push(p);
						} else if (p === query.value || p >= query.value /*  || p.indexOf(query.value) */ ) value.push(p); // For all
						else value = [];
					}
				}
			}
		}
	}
	toObject(key = '') {

	}
}