const queryArray = {
  key: 'shared',
  value: {
    value: {
      value: 'Foo'
    }
  }
};
const query = {
  key: 'shared',
  value: {
    value: {
      key: 'id',
      value: 'Foo'
    }
  }
};

const dbArray = {
  notes: [{
    title: 'Note 1',
    shared: [
      ['Foo'],
    ]
  }, {
    title: 'Note 2',
    shared: [
      ['User 5'],
      ['User 6']
    ]
  }, {
    title: 'Note 3',
    shared: [{
      name: 'User 2'
    }]
  }]
};

const db = {
  notes: { // Array
    noteID1: {
      title: 'Note 1',
      shared: { // Array
        userID1: {
          loop1: 'Foo'
        },
        userID2: 'User 6',
        userID3: 'User',
      }
    },
    noteID2: {
      title: 'Note 2',
      shared: { // Array
        userID1: {
          name: 'User 1',
        },
        userID2: {
          name: 'User 2',
        }
      }
    },
    noteID3: {
      title: 'Note 3',
      shared: { // Array
        userID1: 'User 5',
        userID2: 'User 6',
        userID3: 'User',
      }
    }
  }
};

const deepQuery = (obj = {}, query = {}, options = {}) => {
  let array = [],
    p = {};
  for (let key in obj) {
    // key in this case is the iterated index of the obj, just as an array is
    p = obj[key];
    // With key
    if (query.key != undefined) {
      if (p[query.key] != undefined) {
        if (typeof query.value == 'object') {
          if (deepQuery(p[query.key], query.value, options).length > 0) array.push(p);
        } else {
          if (options.contains) { // For string
            // !TASK: loop string array and convert to lowercase before equating...
            if (p[query.key].indexOf(query.value) > -1) array.push(p);
          } else if (options.ranged) { // For number
            if (p[query.key] >= query.value) array.push(p);
          } else if (options.exact) { // For boolean
            if (p[query.key] === query.value) array.push(p);
          } else if (p[query.key] === query.value || p[query.key] >= query.value || p[query.key].indexOf(query.value)) array.push(p); // For all
          else array = [];
        }
      }
    } else { // Without key
      if (p != undefined) {
        if (typeof query.value == 'object') {
          if (deepQuery(p, query.value, options).length > 0) array.push(p);
        } else {
          if (options.contains) { // For string
            if (p.indexOf(query.value) > -1) array.push(p);
          } else if (options.ranged) { // For number
            if (p >= query.value) array.push(p);
          } else if (options.exact) { // For boolean
            if (p === query.value) array.push(p);
          } else if (p === query.value || p >= query.value || p.indexOf(query.value)) array.push(p); // For all
          else array = [];
        }
      }
    }
  }
  return array;
};
(() => {
  console.log('Query: ', deepQuery(db.notes, query, {
    exact: true
  }));
})();